<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Blob Generator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #371b53;
            font-family: Arial, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        /* Control Panel Styles */
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            padding: 20px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
            font-size: 14px;
            color: white;
        }
        
        .control-section {
            margin-bottom: 20px;
            border: 1px solid #333;
            border-radius: 6px;
            background: rgba(20, 20, 20, 0.5);
        }
        
        .section-header {
            background: #2a2a2a;
            padding: 12px 16px;
            margin: 0;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .section-content {
            padding: 16px;
            display: none;
        }
        
        .section-content.expanded {
            display: block;
        }
        
        .control-group {
            margin-bottom: 16px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        label {
            display: block;
            margin-bottom: 6px;
            font-size: 12px;
            color: #ccc;
        }
        
        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #333;
            outline: none;
            border-radius: 2px;
            appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: #00fff8;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #00fff8;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .range-value {
            float: right;
            font-size: 11px;
            color: #999;
        }
        
        input[type="color"] {
            width: 100%;
            height: 32px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        select {
            width: 100%;
            height: 32px;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            color: white;
            padding: 0 8px;
            cursor: pointer;
        }
        
        select option {
            background: #333;
            color: white;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="info">3D Blob Mixer - Click and drag to rotate</div>
    <div id="container"></div>
    
    <div id="controls">
        <!-- Blob Material Section -->
        <div class="control-section">
            <h3 class="section-header" onclick="toggleSection('blob-material')">
                Blob Material <span>âˆ’</span>
            </h3>
            <div class="section-content expanded" id="blob-material">
                <div class="control-group">
                    <label>Color 1 (Cyan)</label>
                    <input type="color" id="color1" value="#00fff8">
                </div>
                <div class="control-group">
                    <label>Color 2 (Purple)</label>
                    <input type="color" id="color2" value="#7800ff">
                </div>
                <div class="control-group">
                    <label>Color 3 (White)</label>
                    <input type="color" id="color3" value="#ffffff">
                </div>
                <div class="control-group">
                    <label>Metalness <span class="range-value" id="metalness-value">1.00</span></label>
                    <input type="range" id="metalness" min="0" max="1" step="0.01" value="1">
                </div>
                <div class="control-group">
                    <label>Roughness <span class="range-value" id="roughness-value">0.36</span></label>
                    <input type="range" id="roughness" min="0" max="1" step="0.01" value="0.36">
                </div>
                <div class="control-group">
                    <label>Clearcoat <span class="range-value" id="clearcoat-value">1.00</span></label>
                    <input type="range" id="clearcoat" min="0" max="1" step="0.01" value="1">
                </div>
                <div class="control-group">
                    <label>IOR <span class="range-value" id="ior-value">2.33</span></label>
                    <input type="range" id="ior" min="1" max="3" step="0.01" value="2.33">
                </div>
                <div class="control-group">
                    <label>Subsurface Scattering <span class="range-value" id="subsurface-value">0.30</span></label>
                    <input type="range" id="subsurface" min="0" max="1" step="0.01" value="0.3">
                </div>
                <div class="control-group">
                    <label>Subsurface Color</label>
                    <input type="color" id="subsurfaceColor" value="#ff6b6b">
                </div>
            </div>
        </div>

        <!-- Blob Noise Section -->
        <div class="control-section">
            <h3 class="section-header" onclick="toggleSection('blob-noise')">
                Blob Noise <span>+</span>
            </h3>
            <div class="section-content" id="blob-noise">
                <div class="control-group">
                    <label>Noise Type</label>
                    <select id="noiseType">
                        <option value="banded" selected>Banded (Original)</option>
                        <option value="worley">Worley/Voronoi</option>
                        <option value="curl">Curl Noise</option>
                        <option value="fbm">Fractal Brownian Motion</option>
                        <option value="mixed">Mixed Complex</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Noise Complexity <span class="range-value" id="noiseComplexity-value">1.00</span></label>
                    <input type="range" id="noiseComplexity" min="0.1" max="3" step="0.01" value="1">
                </div>
                <div class="control-group">
                    <label>Noise Scale <span class="range-value" id="noiseScale-value">1.00</span></label>
                    <input type="range" id="noiseScale" min="0.1" max="5" step="0.01" value="1">
                </div>
                <div class="control-group">
                    <label>Domain Warp <span class="range-value" id="domainWarp-value">0.00</span></label>
                    <input type="range" id="domainWarp" min="0" max="2" step="0.01" value="0">
                </div>
                <div class="control-group">
                    <label>Frequency <span class="range-value" id="frequency-value">3.05</span></label>
                    <input type="range" id="frequency" min="0.1" max="10" step="0.01" value="3.05">
                </div>
                <div class="control-group">
                    <label>Num Waves <span class="range-value" id="numWaves-value">12.07</span></label>
                    <input type="range" id="numWaves" min="1" max="30" step="0.01" value="12.07">
                </div>
                <div class="control-group">
                    <label>Surface Distort <span class="range-value" id="surfaceDistort-value">1.40</span></label>
                    <input type="range" id="surfaceDistort" min="0" max="3" step="0.01" value="1.4">
                </div>
                <div class="control-group">
                    <label>Surface Frequency <span class="range-value" id="surfaceFrequency-value">1.74</span></label>
                    <input type="range" id="surfaceFrequency" min="0.1" max="5" step="0.01" value="1.74">
                </div>
                <div class="control-group">
                    <label>Speed <span class="range-value" id="speed-value">4.00</span></label>
                    <input type="range" id="speed" min="0" max="10" step="0.1" value="4">
                </div>
                <div class="control-group">
                    <label>Decay <span class="range-value" id="decay1-value">1.00</span></label>
                    <input type="range" id="decay1" min="0.1" max="2" step="0.01" value="1">
                </div>
                <div class="control-group">
                    <label>Angle 1 <span class="range-value" id="angle1-value">0.42</span></label>
                    <input type="range" id="angle1" min="0" max="6.28" step="0.01" value="0.42">
                </div>
                <div class="control-group">
                    <label>Angle 2 <span class="range-value" id="angle2-value">0.52</span></label>
                    <input type="range" id="angle2" min="0" max="6.28" step="0.01" value="0.52">
                </div>
                <div class="control-group">
                    <label>Angle 3 <span class="range-value" id="angle3-value">0.39</span></label>
                    <input type="range" id="angle3" min="0" max="6.28" step="0.01" value="0.39">
                </div>
                <div class="control-group">
                    <label>Surface Pole Amount <span class="range-value" id="surfPoleAmount-value">1.00</span></label>
                    <input type="range" id="surfPoleAmount" min="0" max="2" step="0.01" value="1">
                </div>
                <div class="control-group">
                    <label>Distort <span class="range-value" id="distort-value">0.00</span></label>
                    <input type="range" id="distort" min="0" max="2" step="0.01" value="0">
                </div>
            </div>
        </div>

        <!-- Blob Geometry Section -->
        <div class="control-section">
            <h3 class="section-header" onclick="toggleSection('blob-geometry')">
                Blob Geometry <span>+</span>
            </h3>
            <div class="section-content" id="blob-geometry">
                <div class="control-group">
                    <label>Scale <span class="range-value" id="scale-value">1.03</span></label>
                    <input type="range" id="scale" min="0.1" max="3" step="0.01" value="1.03">
                </div>
                <div class="control-group">
                    <label>Rotation Speed <span class="range-value" id="ry-value">3.16</span></label>
                    <input type="range" id="ry" min="0" max="10" step="0.01" value="3.16">
                </div>
            </div>
        </div>

        <!-- Environment Section -->
        <div class="control-section">
            <h3 class="section-header" onclick="toggleSection('environment')">
                Environment <span>+</span>
            </h3>
            <div class="section-content" id="environment">
                <div class="control-group">
                    <label>Environment Style</label>
                    <select id="envStyle">
                        <option value="studio">Studio HDR</option>
                        <option value="sunset">Sunset HDR</option>
                        <option value="cosmic" selected>Cosmic HDR</option>
                        <option value="minimal">Minimal</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Environment Rotation <span class="range-value" id="envRotation-value">0.00</span></label>
                    <input type="range" id="envRotation" min="0" max="6.28" step="0.01" value="0">
                </div>
            </div>
        </div>

        <!-- Lighting Section -->
        <div class="control-section">
            <h3 class="section-header" onclick="toggleSection('lighting')">
                Lighting <span>+</span>
            </h3>
            <div class="section-content" id="lighting">
                <div class="control-group">
                    <label>Ambient <span class="range-value" id="ambient-value">0.00</span></label>
                    <input type="range" id="ambient" min="0" max="2" step="0.01" value="0">
                </div>
                <div class="control-group">
                    <label>Env Map <span class="range-value" id="envMap-value">1.02</span></label>
                    <input type="range" id="envMap" min="0" max="3" step="0.01" value="1.02">
                </div>
                <div class="control-group">
                    <label>Light 1 Intensity <span class="range-value" id="int1-value">1.27</span></label>
                    <input type="range" id="int1" min="0" max="5" step="0.01" value="1.27">
                </div>
                <div class="control-group">
                    <label>Light 1 Distance <span class="range-value" id="dist1-value">8.27</span></label>
                    <input type="range" id="dist1" min="0" max="20" step="0.01" value="8.27">
                </div>
                <div class="control-group">
                    <label>Light 1 Penumbra <span class="range-value" id="penum1-value">0.66</span></label>
                    <input type="range" id="penum1" min="0" max="2" step="0.01" value="0.66">
                </div>
                <div class="control-group">
                    <label>Light 2 Intensity <span class="range-value" id="int2-value">3.00</span></label>
                    <input type="range" id="int2" min="0" max="5" step="0.01" value="3">
                </div>
                <div class="control-group">
                    <label>Light 2 Distance <span class="range-value" id="dist2-value">9.53</span></label>
                    <input type="range" id="dist2" min="0" max="20" step="0.01" value="9.53">
                </div>
                <div class="control-group">
                    <label>Light 3 Intensity <span class="range-value" id="int3-value">2.00</span></label>
                    <input type="range" id="int3" min="0" max="5" step="0.01" value="2">
                </div>
                <div class="control-group">
                    <label>Light 3 Distance <span class="range-value" id="dist3-value">8.20</span></label>
                    <input type="range" id="dist3" min="0" max="20" step="0.01" value="8.2">
                </div>
                <div class="control-group">
                    <label>Light 3 Penumbra <span class="range-value" id="penum3-value">1.00</span></label>
                    <input type="range" id="penum3" min="0" max="2" step="0.01" value="1">
                </div>
                <div class="control-group">
                    <label>Light 4 Intensity <span class="range-value" id="int4-value">0.00</span></label>
                    <input type="range" id="int4" min="0" max="5" step="0.01" value="0">
                </div>
                <div class="control-group">
                    <label>Light 5 Intensity <span class="range-value" id="int5-value">0.63</span></label>
                    <input type="range" id="int5" min="0" max="5" step="0.01" value="0.63">
                </div>
            </div>
        </div>

        <!-- Post-Processing Section -->
        <div class="control-section">
            <h3 class="section-header" onclick="toggleSection('post-processing')">
                Post-Processing <span>+</span>
            </h3>
            <div class="section-content" id="post-processing">
                <div class="control-group">
                    <label>Bloom Strength <span class="range-value" id="bloomStrength-value">1.50</span></label>
                    <input type="range" id="bloomStrength" min="0" max="3" step="0.01" value="1.5">
                </div>
                <div class="control-group">
                    <label>Bloom Threshold <span class="range-value" id="bloomThreshold-value">0.80</span></label>
                    <input type="range" id="bloomThreshold" min="0" max="2" step="0.01" value="0.8">
                </div>
                <div class="control-group">
                    <label>Exposure <span class="range-value" id="exposure-value">2.00</span></label>
                    <input type="range" id="exposure" min="0.1" max="3" step="0.01" value="2.0">
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        console.log('Starting blob mixer...');
        
        try {
            // Toggle section visibility
            function toggleSection(sectionId) {
                const content = document.getElementById(sectionId);
                if (content) {
                    const header = content.previousElementSibling;
                    const icon = header ? header.querySelector('span') : null;
                    
                    if (content.classList.contains('expanded')) {
                        content.classList.remove('expanded');
                        if (icon) icon.textContent = '+';
                    } else {
                        content.classList.add('expanded');
                        if (icon) icon.textContent = 'âˆ’';
                    }
                }
            }

            // Update range value displays
            function updateRangeValue(id, value) {
                const valueElement = document.getElementById(id + '-value');
                if (valueElement) {
                    valueElement.textContent = parseFloat(value).toFixed(2);
                }
            }

            // Convert hex color to RGB object
            function hexToRgb(hex) {
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;
                return { r, g, b };
            }

            // Parameters from reference - complete set
            let params = {
                ambient: 0,
                angle1: 0.42,
                angle2: 0.52,
                angle3: 0.39,
                clearColor: '#371b53',
                clearcoat: 1,
                color1: { r: 0, g: 1, b: 0.97 },
                color2: { r: 0.47, g: 0, b: 1 },
                color3: { r: 1, g: 1, b: 1 },
                decay1: 1,
                envMap: 1.02,
                frequency: 3.05,
                int1: 1.27,
                int2: 3,
                int3: 2,
                int4: 0,        // Additional lights from reference
                int5: 0.63,
                ior: 2.33,
                metalness: 1,
                numWaves: 12.07,
                roughness: 0.36,
                ry: 3.16,
                scale: 1.03,
                speed: 4,
                surfaceDistort: 1.4,
                surfaceFrequency: 1.74,
                surfacespeed: 1,
                useGradient: true,
                // All light positions from reference
                x1: -5, y1: 0.07, z1: 1.93,
                x2: -2.73, y2: -6.67, z2: 5.73,
                x3: 1.2, y3: 2.67, z3: 4.6,
                x4: 3.07, y4: 0, z4: 3.53,     // Additional light positions
                z5: 6.2,
                // Distance controls from reference
                dist1: 8.27,
                dist2: 9.53,
                dist3: 8.2,
                // Penumbra controls
                penum1: 0.66,
                penum3: 1,
                // Advanced controls that were missing
                subsurface: 0.3,
                subsurfaceColor: { r: 1, g: 0.42, b: 0.42 }, // #ff6b6b
                noiseType: 'banded',
                noiseComplexity: 1.0,
                noiseScale: 1.0,
                domainWarp: 0.0,
                surfPoleAmount: 1,
                distort: 0,
                envStyle: 'cosmic',
                envRotation: 0,
                // Post-processing
                bloomStrength: 1.5,
                bloomThreshold: 0.8,
                exposure: 2.0
            };

            console.log('Parameters initialized:', params);

            // Scene setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(params.clearColor);
            renderer.physicallyCorrectLights = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = params.exposure;
            document.getElementById('container').appendChild(renderer.domElement);

            console.log('Renderer initialized');

            // Simple environment with multiple styles
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            
            function createSimpleEnvironment(style = 'cosmic') {
                const size = 512;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                let gradient;
                switch(style) {
                    case 'studio':
                        gradient = ctx.createLinearGradient(0, 0, 0, size);
                        gradient.addColorStop(0, '#FFFFFF');
                        gradient.addColorStop(0.5, '#F0F0F0');
                        gradient.addColorStop(1, '#808080');
                        break;
                    case 'sunset':
                        gradient = ctx.createLinearGradient(0, 0, 0, size);
                        gradient.addColorStop(0, '#FFE4B5');
                        gradient.addColorStop(0.5, '#FFA500');
                        gradient.addColorStop(1, '#8B0000');
                        break;
                    case 'minimal':
                        gradient = ctx.createLinearGradient(0, 0, 0, size);
                        gradient.addColorStop(0, '#F5F5F5');
                        gradient.addColorStop(1, '#2C2C2C');
                        break;
                    case 'cosmic':
                    default:
                        gradient = ctx.createLinearGradient(0, 0, 0, size);
                        gradient.addColorStop(0, '#87CEEB');
                        gradient.addColorStop(0.5, '#4682B4');
                        gradient.addColorStop(1, '#191970');
                        break;
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, size, size);
                
                return canvas;
            }
            
            let envCanvas = createSimpleEnvironment(params.envStyle);
            let envTexture = new THREE.CanvasTexture(envCanvas);
            envTexture.mapping = THREE.EquirectangularReflectionMapping;
            let cubeTexture = pmremGenerator.fromEquirectangular(envTexture);
            scene.environment = cubeTexture.texture;
            
            function updateEnvironment() {
                const oldCanvas = envCanvas;
                const oldTexture = envTexture;
                const oldCubeTexture = cubeTexture;
                
                envCanvas = createSimpleEnvironment(params.envStyle);
                envTexture = new THREE.CanvasTexture(envCanvas);
                envTexture.mapping = THREE.EquirectangularReflectionMapping;
                envTexture.offset.x = params.envRotation / (Math.PI * 2);
                cubeTexture = pmremGenerator.fromEquirectangular(envTexture);
                scene.environment = cubeTexture.texture;
                
                if (material) {
                    material.envMap = cubeTexture.texture;
                    material.needsUpdate = true;
                }
                
                // Dispose old resources
                oldTexture.dispose();
                oldCubeTexture.texture.dispose();
            }

            console.log('Environment created');

            // Lighting setup with all 5 lights from reference - using PointLights for accurate positioning
            const ambientLight = new THREE.AmbientLight(0xffffff, params.ambient);
            scene.add(ambientLight);

            // Convert colors to hex for lights (using gradient colors)
            const col1Hex = (Math.round(params.color1.r * 255) << 16) | (Math.round(params.color1.g * 255) << 8) | Math.round(params.color1.b * 255);
            const col2Hex = (Math.round(params.color2.r * 255) << 16) | (Math.round(params.color2.g * 255) << 8) | Math.round(params.color2.b * 255);
            const col3Hex = (Math.round(params.color3.r * 255) << 16) | (Math.round(params.color3.g * 255) << 8) | Math.round(params.color3.b * 255);

            // Light 1 - Cyan color, positioned left-back
            const light1 = new THREE.PointLight(col1Hex, params.int1, params.dist1);
            light1.position.set(params.x1, params.y1, params.z1);
            scene.add(light1);

            // Light 2 - Purple color, positioned below-left-front
            const light2 = new THREE.PointLight(col2Hex, params.int2, params.dist2);
            light2.position.set(params.x2, params.y2, params.z2);
            scene.add(light2);

            // Light 3 - White color, positioned upper-right-front (main key light)
            const light3 = new THREE.PointLight(col3Hex, params.int3, params.dist3);
            light3.position.set(params.x3, params.y3, params.z3);
            scene.add(light3);

            // Light 4 - Additional light (intensity 0 in reference, but positioned)
            const light4 = new THREE.PointLight(col1Hex, params.int4, 10);
            light4.position.set(params.x4, params.y4, params.z4);
            scene.add(light4);

            // Light 5 - Additional light with some intensity, positioned behind
            const light5 = new THREE.PointLight(col2Hex, params.int5, 10);
            light5.position.set(0, 0, params.z5);
            scene.add(light5);

            // Store all lights for updates
            const lights = { ambientLight, light1, light2, light3, light4, light5 };

            console.log('Lights created');

            // Create geometry with higher resolution to show the bands clearly
            const geometry = new THREE.SphereGeometry(1, 128, 128);
            const material = new THREE.MeshPhysicalMaterial({
                color: new THREE.Color(1, 1, 1),
                metalness: params.metalness,
                roughness: params.roughness,
                clearcoat: params.clearcoat,
                ior: params.ior,
                envMap: cubeTexture.texture,
                envMapIntensity: params.envMap
            });

            console.log('Material created');

            // Apply shader modifications
            material.onBeforeCompile = function(shader) {
                console.log('Compiling shader...');
                
                // Add uniforms
                shader.uniforms.uTime = { value: 0 };
                shader.uniforms.uFrequency = { value: params.frequency };
                shader.uniforms.uNumWaves = { value: params.numWaves };
                shader.uniforms.uSurfaceDistort = { value: params.surfaceDistort };
                shader.uniforms.uSurfaceFrequency = { value: params.surfaceFrequency };
                shader.uniforms.uSpeed = { value: params.speed };
                shader.uniforms.uAngle1 = { value: params.angle1 };
                shader.uniforms.uAngle2 = { value: params.angle2 };
                shader.uniforms.uAngle3 = { value: params.angle3 };
                shader.uniforms.uDecay1 = { value: params.decay1 };
                shader.uniforms.uColor1 = { value: new THREE.Vector3(params.color1.r, params.color1.g, params.color1.b) };
                shader.uniforms.uColor2 = { value: new THREE.Vector3(params.color2.r, params.color2.g, params.color2.b) };
                shader.uniforms.uColor3 = { value: new THREE.Vector3(params.color3.r, params.color3.g, params.color3.b) };
                shader.uniforms.uUseGradient = { value: params.useGradient ? 1.0 : 0.0 };

                // Vertex shader modifications
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <common>',
                    `
                    #include <common>
                    uniform float uTime;
                    uniform float uFrequency;
                    uniform float uNumWaves;
                    uniform float uSurfaceDistort;
                    uniform float uSurfaceFrequency;
                    uniform float uSpeed;
                    uniform float uAngle1;
                    uniform float uAngle2;
                    uniform float uAngle3;
                    uniform float uDecay1;
                    uniform vec3 uColor1;
                    uniform vec3 uColor2;
                    uniform vec3 uColor3;
                    uniform float uUseGradient;
                    
                    varying vec3 vLocalPos;

                    float bandedNoise(vec3 p, float frequency, float bands) {
                        // Create much stronger horizontal banding like the reference
                        float y = p.y;
                        
                        // Primary banded pattern with sharp transitions
                        float bandPattern = sin(y * bands * 2.0);
                        bandPattern = smoothstep(-0.3, 0.3, bandPattern); // Sharper bands
                        
                        // Add wave modulation for the characteristic look
                        float waveX = sin(y * frequency + p.x * 3.0) * 0.4;
                        float waveZ = cos(y * frequency + p.z * 3.0) * 0.4;
                        
                        // Combine with stronger amplitude
                        return (bandPattern + waveX + waveZ) * 1.5;
                    }

                    float angularNoise(vec3 p, float period) {
                        float cosA1 = cos(uAngle1), sinA1 = sin(uAngle1);
                        float cosA2 = cos(uAngle2), sinA2 = sin(uAngle2);
                        float cosA3 = cos(uAngle3), sinA3 = sin(uAngle3);
                        
                        // Apply rotations for angular variation
                        vec3 rotated = vec3(
                            p.x * cosA1 - p.z * sinA1,
                            p.y * cosA2 - p.x * sinA2,
                            p.z * cosA3 - p.y * sinA3
                        );
                        
                        return bandedNoise(rotated, period, uNumWaves * 0.5);
                    }

                    float multiOctaveNoise(vec3 p, float period) {
                        float value = 0.0;
                        float amplitude = 1.0;
                        float frequency = period;
                        
                        // Primary banded pattern - much stronger
                        value += bandedNoise(p, frequency, uNumWaves) * amplitude * 2.0;
                        
                        // Add detail octaves with proper decay
                        for(int i = 1; i < 3; i++) {
                            frequency *= 2.0;
                            amplitude *= uDecay1 * 0.3;
                            value += angularNoise(p, frequency) * amplitude;
                        }
                        
                        return value;
                    }
                    `
                );

                shader.vertexShader = shader.vertexShader.replace(
                    '#include <begin_vertex>',
                    `
                    float time = uTime * uSpeed * 0.1;
                    vLocalPos = position;
                    
                    // Create much stronger displacement to match reference
                    float mainNoise = multiOctaveNoise(position + time, uFrequency);
                    float surfaceDetail = bandedNoise(position * uSurfaceFrequency + time, 1.0, uNumWaves);
                    
                    // Increase displacement amplitude significantly
                    float displacement = mainNoise * uSurfaceDistort * 0.15; // 3x stronger
                    displacement += surfaceDetail * uSurfaceDistort * 0.08; // More surface detail
                    
                    vec3 transformed = position + normal * displacement;
                    `
                );

                // Fragment shader modifications
                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <common>',
                    `
                    #include <common>
                    uniform float uUseGradient;
                    uniform vec3 uColor1;
                    uniform vec3 uColor2;
                    uniform vec3 uColor3;
                    varying vec3 vLocalPos;
                    
                    vec3 cosmicFusionGradient(vec3 localPos) {
                        float gradientPos = (localPos.y + 1.0) * 0.5;
                        gradientPos = clamp(gradientPos, 0.0, 1.0);
                        
                        vec3 color;
                        if (gradientPos < 0.5) {
                            float t = gradientPos * 2.0;
                            color = mix(uColor1, uColor2, smoothstep(0.0, 1.0, t));
                        } else {
                            float t = (gradientPos - 0.5) * 2.0;
                            color = mix(uColor2, uColor3, smoothstep(0.0, 1.0, t));
                        }
                        
                        return color;
                    }
                    `
                );

                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <color_fragment>',
                    `
                    #include <color_fragment>
                    if (uUseGradient > 0.5) {
                        vec3 gradientColor = cosmicFusionGradient(vLocalPos);
                        diffuseColor.rgb *= gradientColor;
                    }
                    `
                );

                material.userData.shader = shader;
                console.log('Shader compiled successfully');
            };

            // Create mesh
            const blob = new THREE.Mesh(geometry, material);
            blob.scale.setScalar(params.scale);
            scene.add(blob);

            console.log('Blob created');

            // Position camera
            camera.position.set(0, 0, 3);

            // Mouse controls
            let mouseX = 0, mouseY = 0, isMouseDown = false;
            let targetRotationX = 0, targetRotationY = 0;

            function onMouseMove(event) {
                if (isMouseDown) {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    targetRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetRotationX));
                }
                mouseX = event.clientX;
                mouseY = event.clientY;
            }

            function onMouseDown() { isMouseDown = true; }
            function onMouseUp() { isMouseDown = false; }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);

            // Update function
            function updateBlob() {
                try {
                    if (material) {
                        material.metalness = params.metalness;
                        material.roughness = params.roughness;
                        material.clearcoat = params.clearcoat;
                        material.ior = params.ior;
                        material.envMapIntensity = params.envMap;
                    }
                    
                    // Update all 5 lights
                    if (lights.ambientLight) lights.ambientLight.intensity = params.ambient;
                    if (lights.light1) lights.light1.intensity = params.int1;
                    if (lights.light2) lights.light2.intensity = params.int2;
                    if (lights.light3) lights.light3.intensity = params.int3;
                    if (lights.light4) lights.light4.intensity = params.int4;
                    if (lights.light5) lights.light5.intensity = params.int5;
                    
                    // Update light colors based on gradient colors
                    if (lights.light1 && lights.light2 && lights.light3 && lights.light4 && lights.light5) {
                        const col1Hex = (Math.round(params.color1.r * 255) << 16) | (Math.round(params.color1.g * 255) << 8) | Math.round(params.color1.b * 255);
                        const col2Hex = (Math.round(params.color2.r * 255) << 16) | (Math.round(params.color2.g * 255) << 8) | Math.round(params.color2.b * 255);
                        const col3Hex = (Math.round(params.color3.r * 255) << 16) | (Math.round(params.color3.g * 255) << 8) | Math.round(params.color3.b * 255);
                        
                        lights.light1.color.setHex(col1Hex); // Cyan
                        lights.light2.color.setHex(col2Hex); // Purple
                        lights.light3.color.setHex(col3Hex); // White
                        lights.light4.color.setHex(col1Hex); // Cyan
                        lights.light5.color.setHex(col2Hex); // Purple
                    }
                    
                    if (blob) blob.scale.setScalar(params.scale);
                    
                    renderer.toneMappingExposure = params.exposure;
                    
                    if (material && material.userData && material.userData.shader) {
                        const shader = material.userData.shader;
                        if (shader.uniforms.uFrequency) shader.uniforms.uFrequency.value = params.frequency;
                        if (shader.uniforms.uNumWaves) shader.uniforms.uNumWaves.value = params.numWaves;
                        if (shader.uniforms.uSurfaceDistort) shader.uniforms.uSurfaceDistort.value = params.surfaceDistort;
                        if (shader.uniforms.uSurfaceFrequency) shader.uniforms.uSurfaceFrequency.value = params.surfaceFrequency;
                        if (shader.uniforms.uSpeed) shader.uniforms.uSpeed.value = params.speed;
                        if (shader.uniforms.uAngle1) shader.uniforms.uAngle1.value = params.angle1;
                        if (shader.uniforms.uAngle2) shader.uniforms.uAngle2.value = params.angle2;
                        if (shader.uniforms.uAngle3) shader.uniforms.uAngle3.value = params.angle3;
                        if (shader.uniforms.uDecay1) shader.uniforms.uDecay1.value = params.decay1;
                        if (shader.uniforms.uColor1) shader.uniforms.uColor1.value.set(params.color1.r, params.color1.g, params.color1.b);
                        if (shader.uniforms.uColor2) shader.uniforms.uColor2.value.set(params.color2.r, params.color2.g, params.color2.b);
                        if (shader.uniforms.uColor3) shader.uniforms.uColor3.value.set(params.color3.r, params.color3.g, params.color3.b);
                    }
                } catch (e) {
                    console.warn('Update error:', e);
                }
            }

            // Setup controls - complete list
            function setupControls() {
                const rangeControls = [
                    'metalness', 'roughness', 'clearcoat', 'ior', 'envMap', 'ambient',
                    'frequency', 'numWaves', 'surfaceDistort', 'surfaceFrequency', 'speed',
                    'decay1', 'angle1', 'angle2', 'angle3', 'scale', 'ry',
                    'int1', 'int2', 'int3', 'int4', 'int5', 'bloomStrength', 'bloomThreshold', 'exposure',
                    'dist1', 'dist2', 'dist3', 'penum1', 'penum3', 'subsurface',
                    'noiseComplexity', 'noiseScale', 'domainWarp', 'surfPoleAmount', 'distort', 'envRotation'
                ];
                
                rangeControls.forEach(control => {
                    const element = document.getElementById(control);
                    if (element) {
                        element.addEventListener('input', function() {
                            params[control] = parseFloat(this.value);
                            updateRangeValue(control, this.value);
                            updateBlob();
                        });
                    }
                });
                
                // Color controls
                const colorControls = ['color1', 'color2', 'color3', 'subsurfaceColor'];
                colorControls.forEach(control => {
                    const element = document.getElementById(control);
                    if (element) {
                        element.addEventListener('input', function() {
                            params[control] = hexToRgb(this.value);
                            updateBlob();
                        });
                    }
                });
                
                // Dropdown controls
                const noiseTypeElement = document.getElementById('noiseType');
                if (noiseTypeElement) {
                    noiseTypeElement.addEventListener('change', function() {
                        params.noiseType = this.value;
                        updateBlob();
                    });
                }
                
                const envStyleElement = document.getElementById('envStyle');
                if (envStyleElement) {
                    envStyleElement.addEventListener('change', function() {
                        params.envStyle = this.value;
                        updateEnvironment();
                    });
                }
            }

            // Window resize
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            window.addEventListener('resize', onWindowResize);

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                const time = performance.now() * 0.001;
                if (material && material.userData && material.userData.shader) {
                    try {
                        material.userData.shader.uniforms.uTime.value = time;
                    } catch (e) {
                        // Ignore shader errors during updates
                    }
                }
                
                if (blob) {
                    blob.rotation.x += (targetRotationX - blob.rotation.x) * 0.1;
                    blob.rotation.y += (targetRotationY - blob.rotation.y) * 0.1;
                    
                    if (!isMouseDown) {
                        blob.rotation.y += params.ry * 0.0005;
                    }
                }
                
                renderer.render(scene, camera);
            }
            
            // Initialize
            setupControls();
            animate();
            
            console.log('Blob mixer initialized successfully');
            
        } catch (error) {
            console.error('Error initializing blob mixer:', error);
            
            // Fallback: create a simple scene if there's an error
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            
            const geometry = new THREE.SphereGeometry(1, 32, 32);
            const material = new THREE.MeshBasicMaterial({ color: 0x00fff8 });
            const sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);
            
            camera.position.z = 3;
            
            function fallbackAnimate() {
                requestAnimationFrame(fallbackAnimate);
                sphere.rotation.x += 0.01;
                sphere.rotation.y += 0.01;
                renderer.render(scene, camera);
            }
            fallbackAnimate();
        }

        // Make toggleSection globally available
        window.toggleSection = toggleSection;
    </script>
</body>
</html>